//
// The initial text was generated by CLAUDE in response to
// "example to build an octree"
//

#define _CRT_SECURE_NO_WARNINGS 1

#include <cmath>
#include <iostream>
#include <memory>
#include <vector>
#include <algorithm>

// 3D Point structure
struct Point3D {
    float x, y, z;

    Point3D(float x = 0, float y = 0, float z = 0) : x(x), y(y), z(z) {}

    // Distance calculation
    float distanceTo(const Point3D &other) const {
        float dx = x - other.x;
        float dy = y - other.y;
        float dz = z - other.z;
        return std::sqrt(dx * dx + dy * dy + dz * dz);
    }

    void print() const {
        std::cout << "(" << x << ", " << y << ", " << z << ")";
    }
};

// Bounding box for octree nodes
struct BoundingBox {
    Point3D min, max;

    BoundingBox(const Point3D &min, const Point3D &max) : min(min), max(max) {}

    // Check if point is inside bounding box
    bool contains(const Point3D &point) const {
        return point.x >= min.x && point.x <= max.x && point.y >= min.y &&
               point.y <= max.y && point.z >= min.z && point.z <= max.z;
    }

    // Get center point
    Point3D center() const {
        return Point3D((min.x + max.x) / 2, (min.y + max.y) / 2,
                       (min.z + max.z) / 2);
    }

    // Get size (width/height/depth)
    float size() const {
        return std::max({max.x - min.x, max.y - min.y, max.z - min.z});
    }

    void print() const {
        std::cout << "BBox: min";
        min.print();
        std::cout << " max";
        max.print();
        std::cout << std::endl;
    }
};

class OctreeNode {
public:
    BoundingBox bounds;
    std::vector<Point3D> points;
    std::unique_ptr<OctreeNode> children[8];
    bool isLeaf;
    static const int MAX_POINTS_PER_NODE = 10;
    static const int MAX_DEPTH = 8;
    int depth;

    OctreeNode(const BoundingBox &bounds, int depth = 0)
        : bounds(bounds), isLeaf(true), depth(depth) {
        for (int i = 0; i < 8; i++) {
            children[i] = nullptr;
        }
    }

    // Insert a point into the octree
    void insert(const Point3D &point) {
        if (!bounds.contains(point)) {
            return; // Point outside bounds
        }

        if (isLeaf) {
            points.push_back(point);

            // Check if we need to subdivide
            if (points.size() > MAX_POINTS_PER_NODE && depth < MAX_DEPTH) {
                subdivide();
            }
        } else {
            // Insert into appropriate child
            int childIndex = getChildIndex(point);
            if (children[childIndex]) {
                children[childIndex]->insert(point);
            }
        }
    }

    // Find all points within a given radius of a query point
    void rangeQuery(const Point3D &queryPoint, float radius,
                    std::vector<Point3D> &result) const {
        // Check if query sphere intersects with node bounds
        if (!sphereIntersectsBounds(queryPoint, radius)) {
            return;
        }

        if (isLeaf) {
            // Check all points in this leaf
            for (const Point3D &point : points) {
                if (point.distanceTo(queryPoint) <= radius) {
                    result.push_back(point);
                }
            }
        } else {
            // Recursively search children
            for (int i = 0; i < 8; i++) {
                if (children[i]) {
                    children[i]->rangeQuery(queryPoint, radius, result);
                }
            }
        }
    }

    // Find the nearest point to a query point
    Point3D *findNearest(const Point3D &queryPoint, float &bestDistance) {
        Point3D *nearest = nullptr;

        if (isLeaf) {
            for (Point3D &point : points) {
                float dist = point.distanceTo(queryPoint);
                if (dist < bestDistance) {
                    bestDistance = dist;
                    nearest = &point;
                }
            }
        } else {
            // Search children in order of distance to query point
            std::vector<std::pair<int, float>> childDistances;
            for (int i = 0; i < 8; i++) {
                if (children[i]) {
                    Point3D childCenter = children[i]->bounds.center();
                    float dist = childCenter.distanceTo(queryPoint);
                    childDistances.push_back({i, dist});
                }
            }

            // Sort by distance
            std::sort(childDistances.begin(), childDistances.end(),
                      [](const auto &a, const auto &b) {
                          return a.second < b.second;
                      });

            for (const auto &child : childDistances) {
                if (children[child.first]) {
                    Point3D *childNearest = children[child.first]->findNearest(
                        queryPoint, bestDistance);
                    if (childNearest) {
                        nearest = childNearest;
                    }
                }
            }
        }

        return nearest;
    }

    // Get total number of points in subtree
    int getPointCount() const {
        if (isLeaf) {
            return static_cast<int>(points.size());
        } else {
            int count = 0;
            for (int i = 0; i < 8; i++) {
                if (children[i]) {
                    count += children[i]->getPointCount();
                }
            }
            return count;
        }
    }

    // Print octree structure
    void print(int indent = 0) const {
        std::string indentStr(indent * 2, ' ');
        std::cout << indentStr << "Node (depth=" << depth
                  << ", points=" << getPointCount() << "): ";
        bounds.print();

        if (isLeaf) {
            for (const Point3D &point : points) {
                std::cout << indentStr << "  Point: ";
                point.print();
                std::cout << std::endl;
            }
        } else {
            for (int i = 0; i < 8; i++) {
                if (children[i]) {
                    std::cout << indentStr << "Child " << i << ":" << std::endl;
                    children[i]->print(indent + 1);
                }
            }
        }
    }

private:
    void subdivide() {
        if (!isLeaf)
            return;

        Point3D center = bounds.center();
        Point3D min = bounds.min;
        Point3D max = bounds.max;

        // Create 8 child octants
        children[0] =
            std::make_unique<OctreeNode>(BoundingBox(min, center), depth + 1);
        children[1] = std::make_unique<OctreeNode>(
            BoundingBox(Point3D(center.x, min.y, min.z),
                        Point3D(max.x, center.y, center.z)),
            depth + 1);
        children[2] = std::make_unique<OctreeNode>(
            BoundingBox(Point3D(min.x, center.y, min.z),
                        Point3D(center.x, max.y, center.z)),
            depth + 1);
        children[3] = std::make_unique<OctreeNode>(
            BoundingBox(Point3D(center.x, center.y, min.z),
                        Point3D(max.x, max.y, center.z)),
            depth + 1);
        children[4] = std::make_unique<OctreeNode>(
            BoundingBox(Point3D(min.x, min.y, center.z),
                        Point3D(center.x, center.y, max.z)),
            depth + 1);
        children[5] = std::make_unique<OctreeNode>(
            BoundingBox(Point3D(center.x, min.y, center.z),
                        Point3D(max.x, center.y, max.z)),
            depth + 1);
        children[6] = std::make_unique<OctreeNode>(
            BoundingBox(Point3D(min.x, center.y, center.z),
                        Point3D(center.x, max.y, max.z)),
            depth + 1);
        children[7] =
            std::make_unique<OctreeNode>(BoundingBox(center, max), depth + 1);

        // Redistribute points to children
        for (const Point3D &point : points) {
            int childIndex = getChildIndex(point);
            children[childIndex]->insert(point);
        }

        // Clear points and mark as non-leaf
        points.clear();
        isLeaf = false;
    }

    int getChildIndex(const Point3D &point) const {
        Point3D center = bounds.center();
        int index = 0;

        if (point.x >= center.x)
            index |= 1;
        if (point.y >= center.y)
            index |= 2;
        if (point.z >= center.z)
            index |= 4;

        return index;
    }

    bool sphereIntersectsBounds(const Point3D &center, float radius) const {
        // Find closest point on bounding box to sphere center
        float closestX =
            std::max(bounds.min.x, std::min(center.x, bounds.max.x));
        float closestY =
            std::max(bounds.min.y, std::min(center.y, bounds.max.y));
        float closestZ =
            std::max(bounds.min.z, std::min(center.z, bounds.max.z));

        Point3D closest(closestX, closestY, closestZ);
        return center.distanceTo(closest) <= radius;
    }
};

class Octree {
public:
    std::unique_ptr<OctreeNode> root;

    Octree(const BoundingBox &bounds) {
        root = std::make_unique<OctreeNode>(bounds);
    }

    void insert(const Point3D &point) { root->insert(point); }

    std::vector<Point3D> rangeQuery(const Point3D &queryPoint, float radius) {
        std::vector<Point3D> result;
        root->rangeQuery(queryPoint, radius, result);
        return result;
    }

    Point3D *findNearest(const Point3D &queryPoint) {
        float bestDistance = std::numeric_limits<float>::infinity();
        return root->findNearest(queryPoint, bestDistance);
    }

    int getPointCount() const { return root->getPointCount(); }

    void print() const {
        std::cout << "Octree with " << getPointCount()
                  << " points:" << std::endl;
        root->print();
    }
};

// Example usage and test
int main() {
    // Create octree with bounding box from (-10,-10,-10) to (10,10,10)
    BoundingBox bounds(Point3D(-10, -10, -10), Point3D(10, 10, 10));
    Octree octree(bounds);

    // Insert some test points
    std::vector<Point3D> testPoints = {
        Point3D(1, 2, 3),        Point3D(-2, 4, -1),
        Point3D(5, -3, 2),       Point3D(0, 0, 0),
        Point3D(8, 7, 6),        Point3D(-5, -6, -7),
        Point3D(3, 3, 3),        Point3D(-1, -1, -1),
        Point3D(9, 9, 9),        Point3D(-9, -9, -9),
        Point3D(2.5, 1.5, 4.2F),  Point3D(-3.1F, 2.8F, -0.5),
        Point3D(6.7F, -4.3F, 1.9F), Point3D(0.5, 0.5, 0.5),
        Point3D(7.8F, 8.2F, 5.5)};

    std::cout << "Inserting " << testPoints.size() << " points..." << std::endl;
    for (const Point3D &point : testPoints) {
        octree.insert(point);
    }

    std::cout << "\nOctree structure:" << std::endl;
    octree.print();

    // Test range query
    Point3D queryPoint(2, 2, 2);
    float radius = 3.0f;

    std::cout << "\n--- Range Query Test ---" << std::endl;
    std::cout << "Query point: ";
    queryPoint.print();
    std::cout << ", Radius: " << radius << std::endl;

    std::vector<Point3D> nearbyPoints = octree.rangeQuery(queryPoint, radius);
    std::cout << "Found " << nearbyPoints.size()
              << " points within radius:" << std::endl;
    for (const Point3D &point : nearbyPoints) {
        std::cout << "  ";
        point.print();
        std::cout << " (distance: " << point.distanceTo(queryPoint) << ")"
                  << std::endl;
    }

    // Test nearest neighbor
    std::cout << "\n--- Nearest Neighbor Test ---" << std::endl;
    Point3D searchPoint(4, 4, 4);
    std::cout << "Search point: ";
    searchPoint.print();
    std::cout << std::endl;

    Point3D *nearest = octree.findNearest(searchPoint);
    if (nearest) {
        std::cout << "Nearest point: ";
        nearest->print();
        std::cout << " (distance: " << nearest->distanceTo(searchPoint) << ")"
                  << std::endl;
    }

    std::cout << "\nTotal points in octree: " << octree.getPointCount()
              << std::endl;

    return 0;
}