#ifndef MESHTOOLBOX_H
#define MESHTOOLBOX_H

#include <assimp/DefaultLogger.hpp>
#include <assimp/Exceptional.h>
#include <assimp/Exporter.hpp>
#include <assimp/Importer.hpp>
#include <assimp/SceneCombiner.h>
#include <assimp/aabb.h>
#include <assimp/cimport.h>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
#include <assimp/version.h>

#include <json-c/json.h>

#include <Eigen/Dense>

#include <algorithm>
#include <filesystem>
#include <limits>
#include <map>

#include "assimp_aux.h"

#if _WIN32
#   pragma warning(disable : 4390)
#endif

namespace fs = std::filesystem;



#include "TilesetJson.h"

using namespace cesiumjs;

namespace meshtoolbox {
#if 0
}
#endif

typedef aiVector3t<double> Vector3D;

/// @brief (origin, dimensions)
typedef std::pair<Vector3D, Vector3D> box_t;

struct cylinder_t {
    Vector3D origin;
    ai_real height;
    ai_real radius;
};

struct lidarptr_t {
    ai_real x, y, z;
    uint16_t r, g, b;
};

#ifndef M_PI
/** PI definition */
#define M_PI 3.14159265358979323846
/* 3.1415926535897932384626433832795 */
#endif

/// @brief Helper class to produce meshes and scenes
class Toolbox {
public:
    /// @brief Create a cone mesh
    ///
    /// Creates a vertically oriented (Y Up) cone mesh.
    /// @note Generated by Copilot
    /// @param height
    /// @param radius
    /// @param N Number of segments for the base circle
    aiMesh *mesh_cone(double height, double radius, const unsigned N = 32)
    {
        auto mesh = new aiMesh{};
        mesh->mName = "cone";
        mesh->mPrimitiveTypes = aiPrimitiveType_TRIANGLE;

        // Vertices: N base + 1 apex + 1 center of base
        mesh->mNumVertices = N + 2;
        mesh->mVertices = new aiVector3D[mesh->mNumVertices];

        // Apex vertex (top of the cone)
        mesh->mVertices[0] = aiVector3D(0.0, height, 0.0);

        // Base circle vertices
        for (unsigned i = 0; i < N; ++i) {
            double angle = 2.0 * M_PI * i / N;
            double x = radius * cos(angle);
            double z = radius * sin(angle);
            mesh->mVertices[i + 1] = aiVector3D(x, 0.0, z);
        }

        // Center of base
        mesh->mVertices[N + 1] = aiVector3D(0.0, 0.0, 0.0);

        // Faces: N for sides, N for base
        mesh->mNumFaces = 2 * N;
        mesh->mFaces = new aiFace[mesh->mNumFaces];

        // Side faces (triangles)
        for (unsigned i = 0; i < N; ++i) {
            unsigned next = (i + 1) % N;
            mesh->mFaces[i].mNumIndices = 3;
            mesh->mFaces[i].mIndices = new unsigned[3]{0, i + 1, next + 1};
        }

        // Base faces (triangles)
        for (unsigned i = 0; i < N; ++i) {
            unsigned next = (i + 1) % N;
            mesh->mFaces[N + i].mNumIndices = 3;
            mesh->mFaces[N + i].mIndices = new unsigned[3]{N + 1, next + 1, i + 1};
        }

        return mesh;
    }
    /// @brief Create a box mesh
    /// @param origin a corner
    /// @param dimensions another corner
    /// @param name the mesh name. can be null
    /// @return an object pointer. The user owns the object
    aiMesh *mesh_box(aiVector3D const &origin, aiVector3D const &dimensions,
                     const char *name = nullptr) {
        auto box = new aiMesh{};
        box->mName = name ? name : "";
        box->mNumVertices = 8;
        box->mVertices = new aiVector3D[box->mNumVertices];

        auto const &v = dimensions;
        box->mVertices[0] = origin;
        box->mVertices[1] = aiVector3D{origin.x + v.x, origin.y, origin.z};
        box->mVertices[2] =
            aiVector3D{origin.x + v.x, origin.y + v.y, origin.z};
        box->mVertices[3] = aiVector3D{origin.x, origin.y + v.y, origin.z};

        box->mVertices[4] = aiVector3D{origin.x, origin.y, origin.z + v.z};
        box->mVertices[5] =
            aiVector3D{origin.x + v.x, origin.y, origin.z + v.z};
        box->mVertices[6] = origin + dimensions;
        box->mVertices[7] =
            aiVector3D{origin.x, origin.y + v.y, origin.z + v.z};

        box->mNumFaces = 12;
        box->mFaces = new aiFace[box->mNumFaces];
        box->mFaces[0].mNumIndices = 3;
        box->mFaces[0].mIndices = new unsigned[3]{0, 2, 1};

        box->mFaces[1].mNumIndices = 3;
        box->mFaces[1].mIndices = new unsigned[3]{3, 2, 0};

        box->mFaces[2].mNumIndices = 3;
        box->mFaces[2].mIndices = new unsigned[3]{4, 5, 6};

        box->mFaces[3].mNumIndices = 3;
        box->mFaces[3].mIndices = new unsigned[3]{4, 6, 7};

        box->mFaces[4].mNumIndices = 3;
        box->mFaces[4].mIndices = new unsigned[3]{0, 4, 3};

        box->mFaces[5].mNumIndices = 3;
        box->mFaces[5].mIndices = new unsigned[3]{3, 4, 7};

        box->mFaces[6].mNumIndices = 3;
        box->mFaces[6].mIndices = new unsigned[3]{7, 2, 3};

        box->mFaces[7].mNumIndices = 3;
        box->mFaces[7].mIndices = new unsigned[3]{6, 2, 7};

        box->mFaces[8].mNumIndices = 3;
        box->mFaces[8].mIndices = new unsigned[3]{6, 1, 2};

        box->mFaces[9].mNumIndices = 3;
        box->mFaces[9].mIndices = new unsigned[3]{5, 1, 6};

        box->mFaces[10].mNumIndices = 3;
        box->mFaces[10].mIndices = new unsigned[3]{0, 1, 4};

        box->mFaces[11].mNumIndices = 3;
        box->mFaces[11].mIndices = new unsigned[3]{4, 1, 5};

        box->mPrimitiveTypes = aiPrimitiveType_TRIANGLE;

        return box;
    };

    aiMesh *mesh_tile(ai_real width, ai_real height)
    {
        auto box = new aiMesh{};
        box->mName= "tile";
        box->mNumVertices = 4;
        box->mVertices = new aiVector3D[box->mNumVertices];
        box->mPrimitiveTypes = aiPrimitiveType_POLYGON;

        auto origin = aiVector3D{0, 0, 0};
        auto v = aiVector3D{width, height, 0};
        box->mVertices[0] = origin;
        box->mVertices[1] = aiVector3D{origin.x + v.x, origin.y, origin.z};
        box->mVertices[2] = aiVector3D{origin.x + v.x, origin.y + v.y, origin.z};
        box->mVertices[3] = aiVector3D{origin.x, origin.y + v.y, origin.z};

        box->mNumFaces = 1;
        box->mFaces = new aiFace[box->mNumFaces];
        box->mFaces[0].mNumIndices = 4;
        box->mFaces[0].mIndices = new unsigned[4]{0, 1, 2, 3};

        return box;
    }

    /// @brief Create a box point cloud "mesh"
    /// @param origin a corner
    /// @param dimensions another corner
    /// @param name the mesh name. can be null
    /// @return an object pointer. The user owns the object
    aiMesh *mesh_pc_box(aiVector3D const &origin, aiVector3D const &dimensions,
                        const char *name = nullptr) {
        auto box = new aiMesh{};
        box->mName = name ? name : "";
        box->mNumVertices = 8;
        box->mVertices = new aiVector3D[box->mNumVertices];

        auto const &v = dimensions;
        box->mVertices[0] = origin;
        box->mVertices[1] = aiVector3D{origin.x + v.x, origin.y, origin.z};
        box->mVertices[2] =
            aiVector3D{origin.x + v.x, origin.y + v.y, origin.z};
        box->mVertices[3] = aiVector3D{origin.x, origin.y + v.y, origin.z};

        box->mVertices[4] = aiVector3D{origin.x, origin.y, origin.z + v.z};
        box->mVertices[5] =
            aiVector3D{origin.x + v.x, origin.y, origin.z + v.z};
        box->mVertices[6] = origin + dimensions;
        box->mVertices[7] =
            aiVector3D{origin.x, origin.y + v.y, origin.z + v.z};

        box->mNumFaces = 8;
        box->mFaces = new aiFace[box->mNumFaces];

        box->mFaces[0].mNumIndices = 1;
        box->mFaces[0].mIndices = new unsigned[1]{0};

        box->mFaces[1].mNumIndices = 1;
        box->mFaces[1].mIndices = new unsigned[1]{1};

        box->mFaces[2].mNumIndices = 1;
        box->mFaces[2].mIndices = new unsigned[1]{2};

        box->mFaces[3].mNumIndices = 1;
        box->mFaces[3].mIndices = new unsigned[1]{3};

        box->mFaces[4].mNumIndices = 1;
        box->mFaces[4].mIndices = new unsigned[1]{4};

        box->mFaces[5].mNumIndices = 1;
        box->mFaces[5].mIndices = new unsigned[1]{5};

        box->mFaces[6].mNumIndices = 1;
        box->mFaces[6].mIndices = new unsigned[1]{6};

        box->mFaces[7].mNumIndices = 1;
        box->mFaces[7].mIndices = new unsigned[1]{7};

        box->mPrimitiveTypes = aiPrimitiveType_POINT;

        return box;
    };

    /// @brief Create a "mesh" of Lidar points
    /// @param data
    /// @param count
    /// @param name [optional]
    /// @return
    aiMesh *mesh_lidar_pc(lidarptr_t *data, size_t count,
                          const char *name = nullptr) {
        auto box = new aiMesh{};
        box->mName = name ? name : "";
        box->mNumVertices = unsigned(count);
        box->mVertices = new aiVector3D[box->mNumVertices];

        box->mColors[0] = new aiColor4D[box->mNumVertices];

        ai_real d = ai_real(1.0 / 0xFFFF);
        for (unsigned i = 0; i < box->mNumVertices; ++i) {
            box->mVertices[i] = aiVector3D{data[i].x, data[i].z, -data[i].y};
            box->mColors[0][i] =
                aiColor4D{data[i].r * d, data[i].g * d, data[i].b * d, 1.0};
        }

        box->mNumFaces = box->mNumVertices;
        box->mFaces = new aiFace[box->mNumFaces];

        for (unsigned i = 0; i < box->mNumFaces; ++i) {
            box->mFaces[i].mNumIndices = 1;
            box->mFaces[i].mIndices = new unsigned[1]{i};
        }

        box->mPrimitiveTypes = aiPrimitiveType_POINT;

        return box;
    };

    /// @brief Create a single box scene
    /// @param origin coordinate of the origin (a corner)
    /// @param dimensions (x,y,z) dimensions of the box
    /// @return a pointer to a single mesh (the box) scene. The user owns the
    /// object.
    aiScene *make_box(aiVector3D const &origin, aiVector3D const &dimensions) {
        std::unique_ptr<aiScene> model = std::make_unique<aiScene>();

        auto box = mesh_box(origin, dimensions, "box");

        model->mNumMeshes = 1;
        model->mMeshes = new aiMesh *[model->mNumMeshes] { box };

        model->mRootNode = new aiNode("ROOT");
        model->mRootNode->mNumChildren = 1;
        model->mRootNode->mChildren =
            new aiNode *[model->mRootNode->mNumChildren];
        model->mRootNode->mChildren[0] = new aiNode("box");
        model->mRootNode->mChildren[0]->mNumMeshes = 1;
        model->mRootNode->mChildren[0]->mMeshes = new unsigned[1]{0};

        return model.release();
    }

    /// @brief Create a multi-object scene
    /// @param boxes object coordinates
    /// @return
    aiScene *make_boxes(std::vector<box_t> const &boxes, aiMatrix4x4 const &root_transform) {
        std::unique_ptr<aiScene> model = std::make_unique<aiScene>();
        model->mRootNode = new aiNode("ROOT");
        model->mRootNode->mTransformation = root_transform;
        if (boxes.size()) {
            model->mRootNode->mNumChildren = unsigned(boxes.size());
            model->mRootNode->mChildren =
                new aiNode *[model->mRootNode->mNumChildren];
            model->mNumMeshes = unsigned(boxes.size());
            model->mMeshes = new aiMesh *[model->mNumMeshes];

            for (unsigned int i = 0; i != boxes.size(); ++i) {
                std::ostringstream box_name;
                box_name << "box " << boxes[i].second;
                model->mMeshes[i] = mesh_box(boxes[i].first, boxes[i].second,
                                             box_name.str().c_str());
                model->mRootNode->mChildren[i] =
                    new aiNode("box_" + std::to_string(i));
                model->mRootNode->mChildren[i]->mNumMeshes = 1;
                model->mRootNode->mChildren[i]->mMeshes = new unsigned[1]{i};
            }
        }
        return model.release();
    }

    aiScene *make_boxes(std::vector<box_t> const &boxes)
    {
        aiMatrix4x4 t(
            1,0,0,0,
            0,1,0,0,
            0,0,1,0,
            0,0,0,1
        );
        return make_boxes(boxes, t);
    }

    aiScene *make_boxes_yup(std::vector<box_t> const &boxes)
    {
        aiMatrix4x4 t(
            1,0,0,0,
            0,0,1,0,
            0,-1,0,0,
            0,0,0,1
        );
        return make_boxes(boxes, t);
    }

    /// @brief Create a multi-object scene
    /// @param boxes object coordinates
    /// @return
    aiScene *make_boxes_with_transform(std::vector<box_t> const &boxes) {
        static_assert(sizeof(ai_real) == 4);

        std::unique_ptr<aiScene> model = std::make_unique<aiScene>();
        model->mRootNode = new aiNode("ROOT");
        if (boxes.size()) {
            Vector3D origin{0, 0, 0};
            for (auto &bp : boxes) {
                origin += bp.first;
            }

            // compute the origin as a centroid of the boxes
            origin /= static_cast<ai_real>(boxes.size());

            model->mRootNode->mNumChildren = unsigned(boxes.size());
            model->mRootNode->mChildren =
                new aiNode *[model->mRootNode->mNumChildren];
            model->mRootNode->mTransformation =
                make_offset_transformation(origin);
            model->mNumMeshes = unsigned(boxes.size());
            model->mMeshes = new aiMesh *[model->mNumMeshes];

            for (unsigned int i = 0; i != boxes.size(); ++i) {
                std::ostringstream box_name;
                box_name << "box " << boxes[i].second;
                aiVector3D origin_i{boxes[i].first};
                origin_i -= origin;
                model->mMeshes[i] =
                    mesh_box(origin_i, boxes[i].second, box_name.str().c_str());
                model->mRootNode->mChildren[i] =
                    new aiNode("box_" + std::to_string(i));
                model->mRootNode->mChildren[i]->mNumMeshes = 1;
                model->mRootNode->mChildren[i]->mMeshes = new unsigned[1]{i};
            }
        }
        return model.release();
    }

    aiMatrix4x4 make_offset_transformation(Vector3D const &origin) {
        aiMatrix4x4 r;
        aiMatrix4x4::Translation(origin, r);
        return r;
    }

    /// @brief
    /// @param v0
    /// @return
    Eigen::Vector3f to_eigen(aiVector3D const &v0) {
        return Eigen::Vector3f(v0.x, v0.y, v0.z);
    }

    aiVector3D from_eigen(Eigen::Vector3f const &v) {
        return {v.x(), v.y(), v.z()};
    }

    aiVector3D plane_normal(aiVector3D const &v0, aiVector3D const &v1,
                            aiVector3D const &v2) {
        Eigen::Vector3f normal = to_eigen(v1 - v0).cross(to_eigen(v2 - v0));
        return {normal.x(), normal.y(), normal.z()};
    }

    aiMesh *mesh_cylinder(aiVector3D const &origin, ai_real H, ai_real R,
                          unsigned N, const char *name) {
        auto box = new aiMesh{};
        box->mName = name ? name : "";
        box->mPrimitiveTypes = aiPrimitiveType_TRIANGLE;

        //
        box->mNumVertices = (N + 1) * 2;
        box->mVertices = new aiVector3D[box->mNumVertices];

        ai_real a = 0, da = ai_real(2 * M_PI / N);
        for (unsigned i = 0; i < N; ++i) {
            ai_real x = R * cos(a + i * da) + origin.x;
            ai_real z = R * sin(a + i * da) + origin.z;

            box->mVertices[2 * i] = {x, 0, z};
            box->mVertices[2 * i + 1] = {x, H, z};
        }
        box->mVertices[N * 2] = origin;
        box->mVertices[N * 2 + 1] = {origin.x, origin.y + H, origin.z};

        box->mNumFaces = 4 * N;
        box->mFaces = new aiFace[box->mNumFaces];

        // the cylinder sides
        for (unsigned i = 0; i < N; ++i) {
            auto i_next = (i + 1) % N;

            box->mFaces[2 * i].mNumIndices = 3;
            box->mFaces[2 * i].mIndices =
                new unsigned[3]{2 * i, 2 * i + 1, 2 * i_next};

            box->mFaces[2 * i + 1].mNumIndices = 3;
            box->mFaces[2 * i + 1].mIndices =
                new unsigned[3]{2 * i_next, 2 * i + 1, 2 * i_next + 1};
        }

        {
            // The cylinder bottom
            int pos = 2 * N;
            for (unsigned i = 0; i < N; ++i) {
                auto i_next = (i + 1) % N;
                box->mFaces[pos].mNumIndices = 3;
                box->mFaces[pos].mIndices =
                    new unsigned[3]{2 * N, 2 * i, 2 * i_next};
                pos += 1;
            }
            // The cylinder top
            for (unsigned i = 0; i < N; ++i) {
                auto i_next = (i + 1) % N;
                box->mFaces[pos].mNumIndices = 3;
                box->mFaces[pos].mIndices =
                    new unsigned[3]{2 * i + 1, 2 * N + 1, 2 * i_next + 1};
                pos += 1;
            }
        }

        return box;
    }

    aiMesh *mesh_cylinder(ai_real H, ai_real R, unsigned N = 32,
                          const char *name = nullptr) {
        return mesh_cylinder({0, 0, 0}, H, R, N, name);
    }

    /// @brief Create a single cylinder scene
    /// @param origin coordinate of the origin (a center of the cylinder bottom)
    aiScene *make_cylinder(aiVector3D const &origin, ai_real H, ai_real R,
                           unsigned N) {
        std::unique_ptr<aiScene> model = std::make_unique<aiScene>();

        auto box = mesh_cylinder(origin, H, R, N, "cylinder");

        model->mNumMeshes = 1;
        model->mMeshes = new aiMesh *[model->mNumMeshes] { box };

        model->mRootNode = new aiNode("ROOT");
        model->mRootNode->mNumChildren = 1;
        model->mRootNode->mChildren =
            new aiNode *[model->mRootNode->mNumChildren];
        model->mRootNode->mChildren[0] = new aiNode("cylinder");
        model->mRootNode->mChildren[0]->mNumMeshes = 1;
        model->mRootNode->mChildren[0]->mMeshes = new unsigned[1]{0};

        return model.release();
    }

    /// @brief Create a multi-object scene
    /// @param cylinders object parameters
    /// @param N
    /// @return
    aiScene *make_cylinders(std::vector<cylinder_t> const &cylinders,
                            unsigned N) {
        std::unique_ptr<aiScene> model = std::make_unique<aiScene>();
        model->mRootNode = new aiNode("ROOT");
        if (cylinders.size()) {
            model->mRootNode->mNumChildren = unsigned(cylinders.size());
            model->mRootNode->mChildren =
                new aiNode *[model->mRootNode->mNumChildren];
            model->mNumMeshes = unsigned(cylinders.size());
            model->mMeshes = new aiMesh *[model->mNumMeshes];

            for (unsigned int i = 0; i != cylinders.size(); ++i) {
                std::ostringstream box_name;
                box_name << "cylinder_" << i;
                model->mMeshes[i] = mesh_cylinder(
                    cylinders[i].origin, cylinders[i].height,
                    cylinders[i].radius, N, box_name.str().c_str());
                model->mRootNode->mChildren[i] =
                    new aiNode("cyl_" + std::to_string(i));
                model->mRootNode->mChildren[i]->mNumMeshes = 1;
                model->mRootNode->mChildren[i]->mMeshes = new unsigned[1]{i};
            }
        }
        return model.release();
    }

    /// @brief Create a single PC-box scene
    /// @param origin coordinate of the origin (a corner)
    /// @param dimensions (x,y,z) dimensions of the box
    /// @return a pointer to a single mesh (the box) scene. The user owns the
    /// object.
    aiScene *make_pc_box(aiVector3D const &origin,
                         aiVector3D const &dimensions) {
        std::unique_ptr<aiScene> model = std::make_unique<aiScene>();

        auto box = mesh_pc_box(origin, dimensions, "box");

        model->mNumMeshes = 1;
        model->mMeshes = new aiMesh *[model->mNumMeshes] { box };

        model->mRootNode = new aiNode("ROOT");
        model->mRootNode->mNumChildren = 1;
        model->mRootNode->mChildren =
            new aiNode *[model->mRootNode->mNumChildren];
        model->mRootNode->mChildren[0] = new aiNode("pc-box");
        model->mRootNode->mChildren[0]->mNumMeshes = 1;
        model->mRootNode->mChildren[0]->mMeshes = new unsigned[1]{0};

        return model.release();
    }

    aiScene *make_lidar_pc(lidarptr_t *data, size_t count) {
        std::unique_ptr<aiScene> model = std::make_unique<aiScene>();

        auto box = mesh_lidar_pc(data, count, "box");

        model->mNumMeshes = 1;
        model->mMeshes = new aiMesh *[model->mNumMeshes] { box };

        model->mRootNode = new aiNode("ROOT");
        model->mRootNode->mNumChildren = 1;
        model->mRootNode->mChildren =
            new aiNode *[model->mRootNode->mNumChildren];
        model->mRootNode->mChildren[0] = new aiNode("pc-box");
        model->mRootNode->mChildren[0]->mNumMeshes = 1;
        model->mRootNode->mChildren[0]->mMeshes = new unsigned[1]{0};

        return model.release();
    }

    /// @brief Create a scene from the meshes provided
    aiScene *make_scene(std::vector<aiMesh *> meshes) {
        std::unique_ptr<aiScene> model = std::make_unique<aiScene>();
        model->mRootNode = new aiNode("ROOT");

        if (meshes.size()) {
            model->mRootNode->mNumChildren = unsigned(meshes.size());
            model->mRootNode->mChildren =
                new aiNode *[model->mRootNode->mNumChildren];
            model->mNumMeshes = unsigned(meshes.size());
            model->mMeshes = new aiMesh *[model->mNumMeshes];

            for (unsigned int i = 0; i != meshes.size(); ++i) {
                std::ostringstream box_name;
                box_name << "mesh " << i;
                // model->mMeshes[i] = mesh_cylinder(
                //     cylinders[i].origin, cylinders[i].height,
                //     cylinders[i].radius, N, box_name.str().c_str());
                model->mMeshes[i] = meshes[i]; // TODO: clone
                model->mRootNode->mChildren[i] =
                    new aiNode("mesh_" + std::to_string(i));
                model->mRootNode->mChildren[i]->mNumMeshes = 1;
                model->mRootNode->mChildren[i]->mMeshes = new unsigned[1]{i};
            }
        }
        return model.release();
    }

    std::vector<aiNode const *> list_nodes(aiScene const *model) {
        std::vector<aiNode const *> r;

        for (int i = 0; i != model->mRootNode->mNumChildren; ++i)
            r.push_back(model->mRootNode->mChildren[i]);
        return r;
    }

    void shift_down(aiNode *node, ai_real off) {
        aiMatrix4x4 t;
        aiVector3D v{0, -off, 0};
        aiMatrix4Translation(&t, &v);

        node->mTransformation = t * node->mTransformation;
    }

    void shift_up(aiNode *node, ai_real off) { return shift_down(node, -off); }

    void turn_around_X(aiNode *node, ai_real angle_deg)
    {
        aiMatrix4x4 t;
        aiMatrix4RotationX(&t, AI_MATH_PI * angle_deg / 180.0);

        node->mTransformation = t * node->mTransformation;
    }

    void turn_around_Z(aiNode *node, ai_real angle_deg)
    {
        aiMatrix4x4 t;
        aiMatrix4RotationZ(&t, AI_MATH_PI * angle_deg / 180.0);

        node->mTransformation = t * node->mTransformation;
    }

    void paint_mesh(aiMesh *mesh, aiColor4D const &color)
    {
        if(!mesh->mColors[0])
            mesh->mColors[0] = new aiColor4D[mesh->mNumVertices];
        for (int i = 0 ; i != mesh->mNumVertices ; ++i)
            mesh->mColors[0][i] = color;
    }
};

}; // namespace meshtoolbox

#endif
